//********************************************************************************************************
//
// Â© 2016 Regents of the University of California on behalf of the University of California at Berkeley
//       with rights granted for USDOT OSADP distribution with the ECL-2.0 open source license.
//
//*********************************************************************************************************
/*
 * Generated by asn1c-0.9.28 (http://lionet.info/asn1c)
 * From ASN.1 module "DSRC"
 * 	found in "../j2735_asn/J2735_201601_ASN_mmitss.asn"
 * 	`asn1c -fcompound-names -gen-PER`
 */

#include "RegionalExtension.h"

static int
memb_regionId_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_4(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_4(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_7(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_7(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_10(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_10(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_13(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_13(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_16(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_16(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_19(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_19(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_22(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_22(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_25(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_25(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_28(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_28(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_31(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_31(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_34(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_34(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_37(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_37(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_40(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_40(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_43(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_43(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_46(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_46(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_49(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_49(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_52(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_52(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_55(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_55(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_58(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_58(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_61(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_61(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_64(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_64(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_67(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_67(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_70(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_70(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_73(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_73(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_76(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_76(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_79(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_79(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_82(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_82(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_85(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_85(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_88(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_88(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_91(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_91(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_94(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_94(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_97(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_97(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_100(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_100(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_103(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_103(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_106(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_106(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_109(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_109(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_112(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_112(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_115(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_115(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_118(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_118(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_121(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_121(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_124(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_124(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_127(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_127(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_130(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_130(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_133(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_133(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_136(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_136(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_139(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_139(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_142(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_142(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_145(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_145(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_148(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_148(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_151(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_151(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_154(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_154(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_157(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_157(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_160(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_160(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_163(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_163(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_166(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_166(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_169(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_169(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_172(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_172(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_175(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_175(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_178(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_178(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_regionId_constraint_181(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long long *)sptr;
	
	if((value >= 0LL && value <= 255LL)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_regExtValue_constraint_181(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

static asn_per_constraints_t asn_PER_memb_regionId_constr_2 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_3 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_5 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_6 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_8 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_9 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_11 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_12 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_14 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_15 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_17 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_18 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_20 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_21 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_23 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_24 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_26 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_27 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_29 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_30 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_32 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_33 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_35 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_36 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_38 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_39 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_41 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_42 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_44 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_45 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_47 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_48 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_50 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_51 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_53 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_54 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_56 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_57 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_59 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_60 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_62 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_63 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_65 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_66 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_68 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_69 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_71 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_72 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_74 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_75 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_77 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_78 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_80 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_81 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_83 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_84 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_86 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_87 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_89 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_90 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_92 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_93 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_95 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_96 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_98 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_99 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_101 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_102 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_104 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_105 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_107 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_108 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_110 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_111 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_113 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_114 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_116 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_117 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_119 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_120 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_122 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_123 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_125 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_126 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_128 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_129 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_131 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_132 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_134 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_135 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_137 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_138 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_140 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_141 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_143 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_144 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_146 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_147 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_149 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_150 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_152 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_153 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_155 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_156 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_158 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_159 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_161 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_162 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_164 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_165 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_167 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_168 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_170 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_171 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_173 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_174 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_176 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_177 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_179 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_180 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regionId_constr_182 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 8,  8,  0l,  255l }	/* (0..255) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_regExtValue_constr_183 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_TYPE_member_t asn_MBR_RegionalExtension_92P0_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P0, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_1,
		&asn_PER_memb_regionId_constr_2,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P0, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_1,
		&asn_PER_memb_regExtValue_constr_3,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P0_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P0_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P0_specs_1 = {
	sizeof(struct RegionalExtension_92P0),
	offsetof(struct RegionalExtension_92P0, _asn_ctx),
	asn_MAP_RegionalExtension_92P0_tag2el_1,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P0 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P0_tags_1,
	sizeof(asn_DEF_RegionalExtension_92P0_tags_1)
		/sizeof(asn_DEF_RegionalExtension_92P0_tags_1[0]), /* 1 */
	asn_DEF_RegionalExtension_92P0_tags_1,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P0_tags_1)
		/sizeof(asn_DEF_RegionalExtension_92P0_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P0_1,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P0_specs_1	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P1_4[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P1, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_4,
		&asn_PER_memb_regionId_constr_5,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P1, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_4,
		&asn_PER_memb_regExtValue_constr_6,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P1_tags_4[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P1_tag2el_4[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P1_specs_4 = {
	sizeof(struct RegionalExtension_92P1),
	offsetof(struct RegionalExtension_92P1, _asn_ctx),
	asn_MAP_RegionalExtension_92P1_tag2el_4,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P1 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P1_tags_4,
	sizeof(asn_DEF_RegionalExtension_92P1_tags_4)
		/sizeof(asn_DEF_RegionalExtension_92P1_tags_4[0]), /* 1 */
	asn_DEF_RegionalExtension_92P1_tags_4,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P1_tags_4)
		/sizeof(asn_DEF_RegionalExtension_92P1_tags_4[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P1_4,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P1_specs_4	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P2_7[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P2, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_7,
		&asn_PER_memb_regionId_constr_8,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P2, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_7,
		&asn_PER_memb_regExtValue_constr_9,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P2_tags_7[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P2_tag2el_7[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P2_specs_7 = {
	sizeof(struct RegionalExtension_92P2),
	offsetof(struct RegionalExtension_92P2, _asn_ctx),
	asn_MAP_RegionalExtension_92P2_tag2el_7,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P2 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P2_tags_7,
	sizeof(asn_DEF_RegionalExtension_92P2_tags_7)
		/sizeof(asn_DEF_RegionalExtension_92P2_tags_7[0]), /* 1 */
	asn_DEF_RegionalExtension_92P2_tags_7,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P2_tags_7)
		/sizeof(asn_DEF_RegionalExtension_92P2_tags_7[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P2_7,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P2_specs_7	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P3_10[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P3, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_10,
		&asn_PER_memb_regionId_constr_11,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P3, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_10,
		&asn_PER_memb_regExtValue_constr_12,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P3_tags_10[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P3_tag2el_10[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P3_specs_10 = {
	sizeof(struct RegionalExtension_92P3),
	offsetof(struct RegionalExtension_92P3, _asn_ctx),
	asn_MAP_RegionalExtension_92P3_tag2el_10,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P3 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P3_tags_10,
	sizeof(asn_DEF_RegionalExtension_92P3_tags_10)
		/sizeof(asn_DEF_RegionalExtension_92P3_tags_10[0]), /* 1 */
	asn_DEF_RegionalExtension_92P3_tags_10,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P3_tags_10)
		/sizeof(asn_DEF_RegionalExtension_92P3_tags_10[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P3_10,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P3_specs_10	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P4_13[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P4, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_13,
		&asn_PER_memb_regionId_constr_14,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P4, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_13,
		&asn_PER_memb_regExtValue_constr_15,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P4_tags_13[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P4_tag2el_13[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P4_specs_13 = {
	sizeof(struct RegionalExtension_92P4),
	offsetof(struct RegionalExtension_92P4, _asn_ctx),
	asn_MAP_RegionalExtension_92P4_tag2el_13,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P4 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P4_tags_13,
	sizeof(asn_DEF_RegionalExtension_92P4_tags_13)
		/sizeof(asn_DEF_RegionalExtension_92P4_tags_13[0]), /* 1 */
	asn_DEF_RegionalExtension_92P4_tags_13,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P4_tags_13)
		/sizeof(asn_DEF_RegionalExtension_92P4_tags_13[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P4_13,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P4_specs_13	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P5_16[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P5, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_16,
		&asn_PER_memb_regionId_constr_17,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P5, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_16,
		&asn_PER_memb_regExtValue_constr_18,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P5_tags_16[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P5_tag2el_16[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P5_specs_16 = {
	sizeof(struct RegionalExtension_92P5),
	offsetof(struct RegionalExtension_92P5, _asn_ctx),
	asn_MAP_RegionalExtension_92P5_tag2el_16,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P5 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P5_tags_16,
	sizeof(asn_DEF_RegionalExtension_92P5_tags_16)
		/sizeof(asn_DEF_RegionalExtension_92P5_tags_16[0]), /* 1 */
	asn_DEF_RegionalExtension_92P5_tags_16,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P5_tags_16)
		/sizeof(asn_DEF_RegionalExtension_92P5_tags_16[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P5_16,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P5_specs_16	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P6_19[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P6, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_19,
		&asn_PER_memb_regionId_constr_20,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P6, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_19,
		&asn_PER_memb_regExtValue_constr_21,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P6_tags_19[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P6_tag2el_19[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P6_specs_19 = {
	sizeof(struct RegionalExtension_92P6),
	offsetof(struct RegionalExtension_92P6, _asn_ctx),
	asn_MAP_RegionalExtension_92P6_tag2el_19,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P6 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P6_tags_19,
	sizeof(asn_DEF_RegionalExtension_92P6_tags_19)
		/sizeof(asn_DEF_RegionalExtension_92P6_tags_19[0]), /* 1 */
	asn_DEF_RegionalExtension_92P6_tags_19,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P6_tags_19)
		/sizeof(asn_DEF_RegionalExtension_92P6_tags_19[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P6_19,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P6_specs_19	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P7_22[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P7, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_22,
		&asn_PER_memb_regionId_constr_23,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P7, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_22,
		&asn_PER_memb_regExtValue_constr_24,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P7_tags_22[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P7_tag2el_22[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P7_specs_22 = {
	sizeof(struct RegionalExtension_92P7),
	offsetof(struct RegionalExtension_92P7, _asn_ctx),
	asn_MAP_RegionalExtension_92P7_tag2el_22,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P7 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P7_tags_22,
	sizeof(asn_DEF_RegionalExtension_92P7_tags_22)
		/sizeof(asn_DEF_RegionalExtension_92P7_tags_22[0]), /* 1 */
	asn_DEF_RegionalExtension_92P7_tags_22,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P7_tags_22)
		/sizeof(asn_DEF_RegionalExtension_92P7_tags_22[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P7_22,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P7_specs_22	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P8_25[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P8, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_25,
		&asn_PER_memb_regionId_constr_26,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P8, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_25,
		&asn_PER_memb_regExtValue_constr_27,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P8_tags_25[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P8_tag2el_25[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P8_specs_25 = {
	sizeof(struct RegionalExtension_92P8),
	offsetof(struct RegionalExtension_92P8, _asn_ctx),
	asn_MAP_RegionalExtension_92P8_tag2el_25,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P8 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P8_tags_25,
	sizeof(asn_DEF_RegionalExtension_92P8_tags_25)
		/sizeof(asn_DEF_RegionalExtension_92P8_tags_25[0]), /* 1 */
	asn_DEF_RegionalExtension_92P8_tags_25,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P8_tags_25)
		/sizeof(asn_DEF_RegionalExtension_92P8_tags_25[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P8_25,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P8_specs_25	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P9_28[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P9, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_28,
		&asn_PER_memb_regionId_constr_29,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P9, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_28,
		&asn_PER_memb_regExtValue_constr_30,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P9_tags_28[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P9_tag2el_28[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P9_specs_28 = {
	sizeof(struct RegionalExtension_92P9),
	offsetof(struct RegionalExtension_92P9, _asn_ctx),
	asn_MAP_RegionalExtension_92P9_tag2el_28,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P9 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P9_tags_28,
	sizeof(asn_DEF_RegionalExtension_92P9_tags_28)
		/sizeof(asn_DEF_RegionalExtension_92P9_tags_28[0]), /* 1 */
	asn_DEF_RegionalExtension_92P9_tags_28,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P9_tags_28)
		/sizeof(asn_DEF_RegionalExtension_92P9_tags_28[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P9_28,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P9_specs_28	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P10_31[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P10, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_31,
		&asn_PER_memb_regionId_constr_32,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P10, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_31,
		&asn_PER_memb_regExtValue_constr_33,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P10_tags_31[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P10_tag2el_31[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P10_specs_31 = {
	sizeof(struct RegionalExtension_92P10),
	offsetof(struct RegionalExtension_92P10, _asn_ctx),
	asn_MAP_RegionalExtension_92P10_tag2el_31,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P10 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P10_tags_31,
	sizeof(asn_DEF_RegionalExtension_92P10_tags_31)
		/sizeof(asn_DEF_RegionalExtension_92P10_tags_31[0]), /* 1 */
	asn_DEF_RegionalExtension_92P10_tags_31,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P10_tags_31)
		/sizeof(asn_DEF_RegionalExtension_92P10_tags_31[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P10_31,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P10_specs_31	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P11_34[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P11, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_34,
		&asn_PER_memb_regionId_constr_35,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P11, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_34,
		&asn_PER_memb_regExtValue_constr_36,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P11_tags_34[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P11_tag2el_34[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P11_specs_34 = {
	sizeof(struct RegionalExtension_92P11),
	offsetof(struct RegionalExtension_92P11, _asn_ctx),
	asn_MAP_RegionalExtension_92P11_tag2el_34,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P11 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P11_tags_34,
	sizeof(asn_DEF_RegionalExtension_92P11_tags_34)
		/sizeof(asn_DEF_RegionalExtension_92P11_tags_34[0]), /* 1 */
	asn_DEF_RegionalExtension_92P11_tags_34,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P11_tags_34)
		/sizeof(asn_DEF_RegionalExtension_92P11_tags_34[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P11_34,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P11_specs_34	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P12_37[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P12, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_37,
		&asn_PER_memb_regionId_constr_38,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P12, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_37,
		&asn_PER_memb_regExtValue_constr_39,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P12_tags_37[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P12_tag2el_37[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P12_specs_37 = {
	sizeof(struct RegionalExtension_92P12),
	offsetof(struct RegionalExtension_92P12, _asn_ctx),
	asn_MAP_RegionalExtension_92P12_tag2el_37,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P12 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P12_tags_37,
	sizeof(asn_DEF_RegionalExtension_92P12_tags_37)
		/sizeof(asn_DEF_RegionalExtension_92P12_tags_37[0]), /* 1 */
	asn_DEF_RegionalExtension_92P12_tags_37,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P12_tags_37)
		/sizeof(asn_DEF_RegionalExtension_92P12_tags_37[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P12_37,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P12_specs_37	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P13_40[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P13, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_40,
		&asn_PER_memb_regionId_constr_41,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P13, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_40,
		&asn_PER_memb_regExtValue_constr_42,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P13_tags_40[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P13_tag2el_40[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P13_specs_40 = {
	sizeof(struct RegionalExtension_92P13),
	offsetof(struct RegionalExtension_92P13, _asn_ctx),
	asn_MAP_RegionalExtension_92P13_tag2el_40,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P13 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P13_tags_40,
	sizeof(asn_DEF_RegionalExtension_92P13_tags_40)
		/sizeof(asn_DEF_RegionalExtension_92P13_tags_40[0]), /* 1 */
	asn_DEF_RegionalExtension_92P13_tags_40,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P13_tags_40)
		/sizeof(asn_DEF_RegionalExtension_92P13_tags_40[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P13_40,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P13_specs_40	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P14_43[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P14, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_43,
		&asn_PER_memb_regionId_constr_44,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P14, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_43,
		&asn_PER_memb_regExtValue_constr_45,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P14_tags_43[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P14_tag2el_43[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P14_specs_43 = {
	sizeof(struct RegionalExtension_92P14),
	offsetof(struct RegionalExtension_92P14, _asn_ctx),
	asn_MAP_RegionalExtension_92P14_tag2el_43,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P14 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P14_tags_43,
	sizeof(asn_DEF_RegionalExtension_92P14_tags_43)
		/sizeof(asn_DEF_RegionalExtension_92P14_tags_43[0]), /* 1 */
	asn_DEF_RegionalExtension_92P14_tags_43,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P14_tags_43)
		/sizeof(asn_DEF_RegionalExtension_92P14_tags_43[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P14_43,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P14_specs_43	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P15_46[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P15, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_46,
		&asn_PER_memb_regionId_constr_47,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P15, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_46,
		&asn_PER_memb_regExtValue_constr_48,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P15_tags_46[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P15_tag2el_46[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P15_specs_46 = {
	sizeof(struct RegionalExtension_92P15),
	offsetof(struct RegionalExtension_92P15, _asn_ctx),
	asn_MAP_RegionalExtension_92P15_tag2el_46,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P15 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P15_tags_46,
	sizeof(asn_DEF_RegionalExtension_92P15_tags_46)
		/sizeof(asn_DEF_RegionalExtension_92P15_tags_46[0]), /* 1 */
	asn_DEF_RegionalExtension_92P15_tags_46,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P15_tags_46)
		/sizeof(asn_DEF_RegionalExtension_92P15_tags_46[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P15_46,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P15_specs_46	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P16_49[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P16, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_49,
		&asn_PER_memb_regionId_constr_50,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P16, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_49,
		&asn_PER_memb_regExtValue_constr_51,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P16_tags_49[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P16_tag2el_49[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P16_specs_49 = {
	sizeof(struct RegionalExtension_92P16),
	offsetof(struct RegionalExtension_92P16, _asn_ctx),
	asn_MAP_RegionalExtension_92P16_tag2el_49,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P16 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P16_tags_49,
	sizeof(asn_DEF_RegionalExtension_92P16_tags_49)
		/sizeof(asn_DEF_RegionalExtension_92P16_tags_49[0]), /* 1 */
	asn_DEF_RegionalExtension_92P16_tags_49,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P16_tags_49)
		/sizeof(asn_DEF_RegionalExtension_92P16_tags_49[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P16_49,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P16_specs_49	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P17_52[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P17, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_52,
		&asn_PER_memb_regionId_constr_53,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P17, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_52,
		&asn_PER_memb_regExtValue_constr_54,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P17_tags_52[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P17_tag2el_52[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P17_specs_52 = {
	sizeof(struct RegionalExtension_92P17),
	offsetof(struct RegionalExtension_92P17, _asn_ctx),
	asn_MAP_RegionalExtension_92P17_tag2el_52,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P17 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P17_tags_52,
	sizeof(asn_DEF_RegionalExtension_92P17_tags_52)
		/sizeof(asn_DEF_RegionalExtension_92P17_tags_52[0]), /* 1 */
	asn_DEF_RegionalExtension_92P17_tags_52,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P17_tags_52)
		/sizeof(asn_DEF_RegionalExtension_92P17_tags_52[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P17_52,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P17_specs_52	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P18_55[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P18, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_55,
		&asn_PER_memb_regionId_constr_56,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P18, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_55,
		&asn_PER_memb_regExtValue_constr_57,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P18_tags_55[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P18_tag2el_55[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P18_specs_55 = {
	sizeof(struct RegionalExtension_92P18),
	offsetof(struct RegionalExtension_92P18, _asn_ctx),
	asn_MAP_RegionalExtension_92P18_tag2el_55,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P18 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P18_tags_55,
	sizeof(asn_DEF_RegionalExtension_92P18_tags_55)
		/sizeof(asn_DEF_RegionalExtension_92P18_tags_55[0]), /* 1 */
	asn_DEF_RegionalExtension_92P18_tags_55,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P18_tags_55)
		/sizeof(asn_DEF_RegionalExtension_92P18_tags_55[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P18_55,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P18_specs_55	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P19_58[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P19, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_58,
		&asn_PER_memb_regionId_constr_59,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P19, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_58,
		&asn_PER_memb_regExtValue_constr_60,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P19_tags_58[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P19_tag2el_58[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P19_specs_58 = {
	sizeof(struct RegionalExtension_92P19),
	offsetof(struct RegionalExtension_92P19, _asn_ctx),
	asn_MAP_RegionalExtension_92P19_tag2el_58,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P19 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P19_tags_58,
	sizeof(asn_DEF_RegionalExtension_92P19_tags_58)
		/sizeof(asn_DEF_RegionalExtension_92P19_tags_58[0]), /* 1 */
	asn_DEF_RegionalExtension_92P19_tags_58,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P19_tags_58)
		/sizeof(asn_DEF_RegionalExtension_92P19_tags_58[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P19_58,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P19_specs_58	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P20_61[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P20, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_61,
		&asn_PER_memb_regionId_constr_62,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P20, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_61,
		&asn_PER_memb_regExtValue_constr_63,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P20_tags_61[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P20_tag2el_61[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P20_specs_61 = {
	sizeof(struct RegionalExtension_92P20),
	offsetof(struct RegionalExtension_92P20, _asn_ctx),
	asn_MAP_RegionalExtension_92P20_tag2el_61,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P20 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P20_tags_61,
	sizeof(asn_DEF_RegionalExtension_92P20_tags_61)
		/sizeof(asn_DEF_RegionalExtension_92P20_tags_61[0]), /* 1 */
	asn_DEF_RegionalExtension_92P20_tags_61,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P20_tags_61)
		/sizeof(asn_DEF_RegionalExtension_92P20_tags_61[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P20_61,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P20_specs_61	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P21_64[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P21, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_64,
		&asn_PER_memb_regionId_constr_65,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P21, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_64,
		&asn_PER_memb_regExtValue_constr_66,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P21_tags_64[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P21_tag2el_64[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P21_specs_64 = {
	sizeof(struct RegionalExtension_92P21),
	offsetof(struct RegionalExtension_92P21, _asn_ctx),
	asn_MAP_RegionalExtension_92P21_tag2el_64,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P21 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P21_tags_64,
	sizeof(asn_DEF_RegionalExtension_92P21_tags_64)
		/sizeof(asn_DEF_RegionalExtension_92P21_tags_64[0]), /* 1 */
	asn_DEF_RegionalExtension_92P21_tags_64,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P21_tags_64)
		/sizeof(asn_DEF_RegionalExtension_92P21_tags_64[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P21_64,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P21_specs_64	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P22_67[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P22, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_67,
		&asn_PER_memb_regionId_constr_68,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P22, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_67,
		&asn_PER_memb_regExtValue_constr_69,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P22_tags_67[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P22_tag2el_67[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P22_specs_67 = {
	sizeof(struct RegionalExtension_92P22),
	offsetof(struct RegionalExtension_92P22, _asn_ctx),
	asn_MAP_RegionalExtension_92P22_tag2el_67,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P22 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P22_tags_67,
	sizeof(asn_DEF_RegionalExtension_92P22_tags_67)
		/sizeof(asn_DEF_RegionalExtension_92P22_tags_67[0]), /* 1 */
	asn_DEF_RegionalExtension_92P22_tags_67,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P22_tags_67)
		/sizeof(asn_DEF_RegionalExtension_92P22_tags_67[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P22_67,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P22_specs_67	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P23_70[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P23, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_70,
		&asn_PER_memb_regionId_constr_71,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P23, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_70,
		&asn_PER_memb_regExtValue_constr_72,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P23_tags_70[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P23_tag2el_70[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P23_specs_70 = {
	sizeof(struct RegionalExtension_92P23),
	offsetof(struct RegionalExtension_92P23, _asn_ctx),
	asn_MAP_RegionalExtension_92P23_tag2el_70,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P23 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P23_tags_70,
	sizeof(asn_DEF_RegionalExtension_92P23_tags_70)
		/sizeof(asn_DEF_RegionalExtension_92P23_tags_70[0]), /* 1 */
	asn_DEF_RegionalExtension_92P23_tags_70,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P23_tags_70)
		/sizeof(asn_DEF_RegionalExtension_92P23_tags_70[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P23_70,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P23_specs_70	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P24_73[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P24, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_73,
		&asn_PER_memb_regionId_constr_74,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P24, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_73,
		&asn_PER_memb_regExtValue_constr_75,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P24_tags_73[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P24_tag2el_73[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P24_specs_73 = {
	sizeof(struct RegionalExtension_92P24),
	offsetof(struct RegionalExtension_92P24, _asn_ctx),
	asn_MAP_RegionalExtension_92P24_tag2el_73,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P24 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P24_tags_73,
	sizeof(asn_DEF_RegionalExtension_92P24_tags_73)
		/sizeof(asn_DEF_RegionalExtension_92P24_tags_73[0]), /* 1 */
	asn_DEF_RegionalExtension_92P24_tags_73,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P24_tags_73)
		/sizeof(asn_DEF_RegionalExtension_92P24_tags_73[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P24_73,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P24_specs_73	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P25_76[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P25, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_76,
		&asn_PER_memb_regionId_constr_77,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P25, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_76,
		&asn_PER_memb_regExtValue_constr_78,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P25_tags_76[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P25_tag2el_76[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P25_specs_76 = {
	sizeof(struct RegionalExtension_92P25),
	offsetof(struct RegionalExtension_92P25, _asn_ctx),
	asn_MAP_RegionalExtension_92P25_tag2el_76,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P25 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P25_tags_76,
	sizeof(asn_DEF_RegionalExtension_92P25_tags_76)
		/sizeof(asn_DEF_RegionalExtension_92P25_tags_76[0]), /* 1 */
	asn_DEF_RegionalExtension_92P25_tags_76,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P25_tags_76)
		/sizeof(asn_DEF_RegionalExtension_92P25_tags_76[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P25_76,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P25_specs_76	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P26_79[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P26, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_79,
		&asn_PER_memb_regionId_constr_80,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P26, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_79,
		&asn_PER_memb_regExtValue_constr_81,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P26_tags_79[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P26_tag2el_79[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P26_specs_79 = {
	sizeof(struct RegionalExtension_92P26),
	offsetof(struct RegionalExtension_92P26, _asn_ctx),
	asn_MAP_RegionalExtension_92P26_tag2el_79,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P26 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P26_tags_79,
	sizeof(asn_DEF_RegionalExtension_92P26_tags_79)
		/sizeof(asn_DEF_RegionalExtension_92P26_tags_79[0]), /* 1 */
	asn_DEF_RegionalExtension_92P26_tags_79,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P26_tags_79)
		/sizeof(asn_DEF_RegionalExtension_92P26_tags_79[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P26_79,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P26_specs_79	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P27_82[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P27, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_82,
		&asn_PER_memb_regionId_constr_83,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P27, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_82,
		&asn_PER_memb_regExtValue_constr_84,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P27_tags_82[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P27_tag2el_82[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P27_specs_82 = {
	sizeof(struct RegionalExtension_92P27),
	offsetof(struct RegionalExtension_92P27, _asn_ctx),
	asn_MAP_RegionalExtension_92P27_tag2el_82,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P27 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P27_tags_82,
	sizeof(asn_DEF_RegionalExtension_92P27_tags_82)
		/sizeof(asn_DEF_RegionalExtension_92P27_tags_82[0]), /* 1 */
	asn_DEF_RegionalExtension_92P27_tags_82,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P27_tags_82)
		/sizeof(asn_DEF_RegionalExtension_92P27_tags_82[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P27_82,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P27_specs_82	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P28_85[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P28, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_85,
		&asn_PER_memb_regionId_constr_86,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P28, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_85,
		&asn_PER_memb_regExtValue_constr_87,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P28_tags_85[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P28_tag2el_85[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P28_specs_85 = {
	sizeof(struct RegionalExtension_92P28),
	offsetof(struct RegionalExtension_92P28, _asn_ctx),
	asn_MAP_RegionalExtension_92P28_tag2el_85,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P28 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P28_tags_85,
	sizeof(asn_DEF_RegionalExtension_92P28_tags_85)
		/sizeof(asn_DEF_RegionalExtension_92P28_tags_85[0]), /* 1 */
	asn_DEF_RegionalExtension_92P28_tags_85,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P28_tags_85)
		/sizeof(asn_DEF_RegionalExtension_92P28_tags_85[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P28_85,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P28_specs_85	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P29_88[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P29, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_88,
		&asn_PER_memb_regionId_constr_89,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P29, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_88,
		&asn_PER_memb_regExtValue_constr_90,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P29_tags_88[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P29_tag2el_88[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P29_specs_88 = {
	sizeof(struct RegionalExtension_92P29),
	offsetof(struct RegionalExtension_92P29, _asn_ctx),
	asn_MAP_RegionalExtension_92P29_tag2el_88,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P29 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P29_tags_88,
	sizeof(asn_DEF_RegionalExtension_92P29_tags_88)
		/sizeof(asn_DEF_RegionalExtension_92P29_tags_88[0]), /* 1 */
	asn_DEF_RegionalExtension_92P29_tags_88,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P29_tags_88)
		/sizeof(asn_DEF_RegionalExtension_92P29_tags_88[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P29_88,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P29_specs_88	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P30_91[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P30, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_91,
		&asn_PER_memb_regionId_constr_92,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P30, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_91,
		&asn_PER_memb_regExtValue_constr_93,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P30_tags_91[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P30_tag2el_91[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P30_specs_91 = {
	sizeof(struct RegionalExtension_92P30),
	offsetof(struct RegionalExtension_92P30, _asn_ctx),
	asn_MAP_RegionalExtension_92P30_tag2el_91,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P30 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P30_tags_91,
	sizeof(asn_DEF_RegionalExtension_92P30_tags_91)
		/sizeof(asn_DEF_RegionalExtension_92P30_tags_91[0]), /* 1 */
	asn_DEF_RegionalExtension_92P30_tags_91,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P30_tags_91)
		/sizeof(asn_DEF_RegionalExtension_92P30_tags_91[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P30_91,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P30_specs_91	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P31_94[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P31, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_94,
		&asn_PER_memb_regionId_constr_95,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P31, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_94,
		&asn_PER_memb_regExtValue_constr_96,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P31_tags_94[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P31_tag2el_94[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P31_specs_94 = {
	sizeof(struct RegionalExtension_92P31),
	offsetof(struct RegionalExtension_92P31, _asn_ctx),
	asn_MAP_RegionalExtension_92P31_tag2el_94,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P31 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P31_tags_94,
	sizeof(asn_DEF_RegionalExtension_92P31_tags_94)
		/sizeof(asn_DEF_RegionalExtension_92P31_tags_94[0]), /* 1 */
	asn_DEF_RegionalExtension_92P31_tags_94,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P31_tags_94)
		/sizeof(asn_DEF_RegionalExtension_92P31_tags_94[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P31_94,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P31_specs_94	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P32_97[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P32, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_97,
		&asn_PER_memb_regionId_constr_98,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P32, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_97,
		&asn_PER_memb_regExtValue_constr_99,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P32_tags_97[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P32_tag2el_97[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P32_specs_97 = {
	sizeof(struct RegionalExtension_92P32),
	offsetof(struct RegionalExtension_92P32, _asn_ctx),
	asn_MAP_RegionalExtension_92P32_tag2el_97,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P32 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P32_tags_97,
	sizeof(asn_DEF_RegionalExtension_92P32_tags_97)
		/sizeof(asn_DEF_RegionalExtension_92P32_tags_97[0]), /* 1 */
	asn_DEF_RegionalExtension_92P32_tags_97,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P32_tags_97)
		/sizeof(asn_DEF_RegionalExtension_92P32_tags_97[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P32_97,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P32_specs_97	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P33_100[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P33, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_100,
		&asn_PER_memb_regionId_constr_101,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P33, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_100,
		&asn_PER_memb_regExtValue_constr_102,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P33_tags_100[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P33_tag2el_100[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P33_specs_100 = {
	sizeof(struct RegionalExtension_92P33),
	offsetof(struct RegionalExtension_92P33, _asn_ctx),
	asn_MAP_RegionalExtension_92P33_tag2el_100,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P33 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P33_tags_100,
	sizeof(asn_DEF_RegionalExtension_92P33_tags_100)
		/sizeof(asn_DEF_RegionalExtension_92P33_tags_100[0]), /* 1 */
	asn_DEF_RegionalExtension_92P33_tags_100,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P33_tags_100)
		/sizeof(asn_DEF_RegionalExtension_92P33_tags_100[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P33_100,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P33_specs_100	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P34_103[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P34, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_103,
		&asn_PER_memb_regionId_constr_104,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P34, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_103,
		&asn_PER_memb_regExtValue_constr_105,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P34_tags_103[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P34_tag2el_103[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P34_specs_103 = {
	sizeof(struct RegionalExtension_92P34),
	offsetof(struct RegionalExtension_92P34, _asn_ctx),
	asn_MAP_RegionalExtension_92P34_tag2el_103,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P34 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P34_tags_103,
	sizeof(asn_DEF_RegionalExtension_92P34_tags_103)
		/sizeof(asn_DEF_RegionalExtension_92P34_tags_103[0]), /* 1 */
	asn_DEF_RegionalExtension_92P34_tags_103,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P34_tags_103)
		/sizeof(asn_DEF_RegionalExtension_92P34_tags_103[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P34_103,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P34_specs_103	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P35_106[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P35, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_106,
		&asn_PER_memb_regionId_constr_107,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P35, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_106,
		&asn_PER_memb_regExtValue_constr_108,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P35_tags_106[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P35_tag2el_106[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P35_specs_106 = {
	sizeof(struct RegionalExtension_92P35),
	offsetof(struct RegionalExtension_92P35, _asn_ctx),
	asn_MAP_RegionalExtension_92P35_tag2el_106,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P35 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P35_tags_106,
	sizeof(asn_DEF_RegionalExtension_92P35_tags_106)
		/sizeof(asn_DEF_RegionalExtension_92P35_tags_106[0]), /* 1 */
	asn_DEF_RegionalExtension_92P35_tags_106,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P35_tags_106)
		/sizeof(asn_DEF_RegionalExtension_92P35_tags_106[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P35_106,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P35_specs_106	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P36_109[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P36, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_109,
		&asn_PER_memb_regionId_constr_110,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P36, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_109,
		&asn_PER_memb_regExtValue_constr_111,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P36_tags_109[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P36_tag2el_109[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P36_specs_109 = {
	sizeof(struct RegionalExtension_92P36),
	offsetof(struct RegionalExtension_92P36, _asn_ctx),
	asn_MAP_RegionalExtension_92P36_tag2el_109,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P36 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P36_tags_109,
	sizeof(asn_DEF_RegionalExtension_92P36_tags_109)
		/sizeof(asn_DEF_RegionalExtension_92P36_tags_109[0]), /* 1 */
	asn_DEF_RegionalExtension_92P36_tags_109,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P36_tags_109)
		/sizeof(asn_DEF_RegionalExtension_92P36_tags_109[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P36_109,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P36_specs_109	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P37_112[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P37, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_112,
		&asn_PER_memb_regionId_constr_113,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P37, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_112,
		&asn_PER_memb_regExtValue_constr_114,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P37_tags_112[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P37_tag2el_112[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P37_specs_112 = {
	sizeof(struct RegionalExtension_92P37),
	offsetof(struct RegionalExtension_92P37, _asn_ctx),
	asn_MAP_RegionalExtension_92P37_tag2el_112,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P37 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P37_tags_112,
	sizeof(asn_DEF_RegionalExtension_92P37_tags_112)
		/sizeof(asn_DEF_RegionalExtension_92P37_tags_112[0]), /* 1 */
	asn_DEF_RegionalExtension_92P37_tags_112,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P37_tags_112)
		/sizeof(asn_DEF_RegionalExtension_92P37_tags_112[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P37_112,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P37_specs_112	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P38_115[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P38, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_115,
		&asn_PER_memb_regionId_constr_116,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P38, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_115,
		&asn_PER_memb_regExtValue_constr_117,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P38_tags_115[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P38_tag2el_115[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P38_specs_115 = {
	sizeof(struct RegionalExtension_92P38),
	offsetof(struct RegionalExtension_92P38, _asn_ctx),
	asn_MAP_RegionalExtension_92P38_tag2el_115,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P38 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P38_tags_115,
	sizeof(asn_DEF_RegionalExtension_92P38_tags_115)
		/sizeof(asn_DEF_RegionalExtension_92P38_tags_115[0]), /* 1 */
	asn_DEF_RegionalExtension_92P38_tags_115,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P38_tags_115)
		/sizeof(asn_DEF_RegionalExtension_92P38_tags_115[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P38_115,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P38_specs_115	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P39_118[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P39, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_118,
		&asn_PER_memb_regionId_constr_119,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P39, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_118,
		&asn_PER_memb_regExtValue_constr_120,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P39_tags_118[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P39_tag2el_118[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P39_specs_118 = {
	sizeof(struct RegionalExtension_92P39),
	offsetof(struct RegionalExtension_92P39, _asn_ctx),
	asn_MAP_RegionalExtension_92P39_tag2el_118,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P39 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P39_tags_118,
	sizeof(asn_DEF_RegionalExtension_92P39_tags_118)
		/sizeof(asn_DEF_RegionalExtension_92P39_tags_118[0]), /* 1 */
	asn_DEF_RegionalExtension_92P39_tags_118,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P39_tags_118)
		/sizeof(asn_DEF_RegionalExtension_92P39_tags_118[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P39_118,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P39_specs_118	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P40_121[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P40, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_121,
		&asn_PER_memb_regionId_constr_122,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P40, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_121,
		&asn_PER_memb_regExtValue_constr_123,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P40_tags_121[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P40_tag2el_121[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P40_specs_121 = {
	sizeof(struct RegionalExtension_92P40),
	offsetof(struct RegionalExtension_92P40, _asn_ctx),
	asn_MAP_RegionalExtension_92P40_tag2el_121,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P40 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P40_tags_121,
	sizeof(asn_DEF_RegionalExtension_92P40_tags_121)
		/sizeof(asn_DEF_RegionalExtension_92P40_tags_121[0]), /* 1 */
	asn_DEF_RegionalExtension_92P40_tags_121,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P40_tags_121)
		/sizeof(asn_DEF_RegionalExtension_92P40_tags_121[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P40_121,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P40_specs_121	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P41_124[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P41, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_124,
		&asn_PER_memb_regionId_constr_125,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P41, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_124,
		&asn_PER_memb_regExtValue_constr_126,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P41_tags_124[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P41_tag2el_124[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P41_specs_124 = {
	sizeof(struct RegionalExtension_92P41),
	offsetof(struct RegionalExtension_92P41, _asn_ctx),
	asn_MAP_RegionalExtension_92P41_tag2el_124,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P41 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P41_tags_124,
	sizeof(asn_DEF_RegionalExtension_92P41_tags_124)
		/sizeof(asn_DEF_RegionalExtension_92P41_tags_124[0]), /* 1 */
	asn_DEF_RegionalExtension_92P41_tags_124,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P41_tags_124)
		/sizeof(asn_DEF_RegionalExtension_92P41_tags_124[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P41_124,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P41_specs_124	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P42_127[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P42, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_127,
		&asn_PER_memb_regionId_constr_128,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P42, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_127,
		&asn_PER_memb_regExtValue_constr_129,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P42_tags_127[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P42_tag2el_127[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P42_specs_127 = {
	sizeof(struct RegionalExtension_92P42),
	offsetof(struct RegionalExtension_92P42, _asn_ctx),
	asn_MAP_RegionalExtension_92P42_tag2el_127,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P42 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P42_tags_127,
	sizeof(asn_DEF_RegionalExtension_92P42_tags_127)
		/sizeof(asn_DEF_RegionalExtension_92P42_tags_127[0]), /* 1 */
	asn_DEF_RegionalExtension_92P42_tags_127,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P42_tags_127)
		/sizeof(asn_DEF_RegionalExtension_92P42_tags_127[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P42_127,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P42_specs_127	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P43_130[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P43, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_130,
		&asn_PER_memb_regionId_constr_131,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P43, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_130,
		&asn_PER_memb_regExtValue_constr_132,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P43_tags_130[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P43_tag2el_130[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P43_specs_130 = {
	sizeof(struct RegionalExtension_92P43),
	offsetof(struct RegionalExtension_92P43, _asn_ctx),
	asn_MAP_RegionalExtension_92P43_tag2el_130,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P43 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P43_tags_130,
	sizeof(asn_DEF_RegionalExtension_92P43_tags_130)
		/sizeof(asn_DEF_RegionalExtension_92P43_tags_130[0]), /* 1 */
	asn_DEF_RegionalExtension_92P43_tags_130,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P43_tags_130)
		/sizeof(asn_DEF_RegionalExtension_92P43_tags_130[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P43_130,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P43_specs_130	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P44_133[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P44, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_133,
		&asn_PER_memb_regionId_constr_134,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P44, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_133,
		&asn_PER_memb_regExtValue_constr_135,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P44_tags_133[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P44_tag2el_133[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P44_specs_133 = {
	sizeof(struct RegionalExtension_92P44),
	offsetof(struct RegionalExtension_92P44, _asn_ctx),
	asn_MAP_RegionalExtension_92P44_tag2el_133,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P44 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P44_tags_133,
	sizeof(asn_DEF_RegionalExtension_92P44_tags_133)
		/sizeof(asn_DEF_RegionalExtension_92P44_tags_133[0]), /* 1 */
	asn_DEF_RegionalExtension_92P44_tags_133,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P44_tags_133)
		/sizeof(asn_DEF_RegionalExtension_92P44_tags_133[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P44_133,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P44_specs_133	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P45_136[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P45, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_136,
		&asn_PER_memb_regionId_constr_137,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P45, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_136,
		&asn_PER_memb_regExtValue_constr_138,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P45_tags_136[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P45_tag2el_136[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P45_specs_136 = {
	sizeof(struct RegionalExtension_92P45),
	offsetof(struct RegionalExtension_92P45, _asn_ctx),
	asn_MAP_RegionalExtension_92P45_tag2el_136,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P45 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P45_tags_136,
	sizeof(asn_DEF_RegionalExtension_92P45_tags_136)
		/sizeof(asn_DEF_RegionalExtension_92P45_tags_136[0]), /* 1 */
	asn_DEF_RegionalExtension_92P45_tags_136,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P45_tags_136)
		/sizeof(asn_DEF_RegionalExtension_92P45_tags_136[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P45_136,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P45_specs_136	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P46_139[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P46, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_139,
		&asn_PER_memb_regionId_constr_140,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P46, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_139,
		&asn_PER_memb_regExtValue_constr_141,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P46_tags_139[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P46_tag2el_139[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P46_specs_139 = {
	sizeof(struct RegionalExtension_92P46),
	offsetof(struct RegionalExtension_92P46, _asn_ctx),
	asn_MAP_RegionalExtension_92P46_tag2el_139,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P46 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P46_tags_139,
	sizeof(asn_DEF_RegionalExtension_92P46_tags_139)
		/sizeof(asn_DEF_RegionalExtension_92P46_tags_139[0]), /* 1 */
	asn_DEF_RegionalExtension_92P46_tags_139,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P46_tags_139)
		/sizeof(asn_DEF_RegionalExtension_92P46_tags_139[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P46_139,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P46_specs_139	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P47_142[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P47, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_142,
		&asn_PER_memb_regionId_constr_143,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P47, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_142,
		&asn_PER_memb_regExtValue_constr_144,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P47_tags_142[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P47_tag2el_142[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P47_specs_142 = {
	sizeof(struct RegionalExtension_92P47),
	offsetof(struct RegionalExtension_92P47, _asn_ctx),
	asn_MAP_RegionalExtension_92P47_tag2el_142,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P47 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P47_tags_142,
	sizeof(asn_DEF_RegionalExtension_92P47_tags_142)
		/sizeof(asn_DEF_RegionalExtension_92P47_tags_142[0]), /* 1 */
	asn_DEF_RegionalExtension_92P47_tags_142,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P47_tags_142)
		/sizeof(asn_DEF_RegionalExtension_92P47_tags_142[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P47_142,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P47_specs_142	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P48_145[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P48, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_145,
		&asn_PER_memb_regionId_constr_146,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P48, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_145,
		&asn_PER_memb_regExtValue_constr_147,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P48_tags_145[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P48_tag2el_145[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P48_specs_145 = {
	sizeof(struct RegionalExtension_92P48),
	offsetof(struct RegionalExtension_92P48, _asn_ctx),
	asn_MAP_RegionalExtension_92P48_tag2el_145,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P48 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P48_tags_145,
	sizeof(asn_DEF_RegionalExtension_92P48_tags_145)
		/sizeof(asn_DEF_RegionalExtension_92P48_tags_145[0]), /* 1 */
	asn_DEF_RegionalExtension_92P48_tags_145,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P48_tags_145)
		/sizeof(asn_DEF_RegionalExtension_92P48_tags_145[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P48_145,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P48_specs_145	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P49_148[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P49, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_148,
		&asn_PER_memb_regionId_constr_149,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P49, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_148,
		&asn_PER_memb_regExtValue_constr_150,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P49_tags_148[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P49_tag2el_148[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P49_specs_148 = {
	sizeof(struct RegionalExtension_92P49),
	offsetof(struct RegionalExtension_92P49, _asn_ctx),
	asn_MAP_RegionalExtension_92P49_tag2el_148,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P49 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P49_tags_148,
	sizeof(asn_DEF_RegionalExtension_92P49_tags_148)
		/sizeof(asn_DEF_RegionalExtension_92P49_tags_148[0]), /* 1 */
	asn_DEF_RegionalExtension_92P49_tags_148,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P49_tags_148)
		/sizeof(asn_DEF_RegionalExtension_92P49_tags_148[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P49_148,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P49_specs_148	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P50_151[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P50, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_151,
		&asn_PER_memb_regionId_constr_152,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P50, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_151,
		&asn_PER_memb_regExtValue_constr_153,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P50_tags_151[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P50_tag2el_151[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P50_specs_151 = {
	sizeof(struct RegionalExtension_92P50),
	offsetof(struct RegionalExtension_92P50, _asn_ctx),
	asn_MAP_RegionalExtension_92P50_tag2el_151,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P50 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P50_tags_151,
	sizeof(asn_DEF_RegionalExtension_92P50_tags_151)
		/sizeof(asn_DEF_RegionalExtension_92P50_tags_151[0]), /* 1 */
	asn_DEF_RegionalExtension_92P50_tags_151,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P50_tags_151)
		/sizeof(asn_DEF_RegionalExtension_92P50_tags_151[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P50_151,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P50_specs_151	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P51_154[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P51, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_154,
		&asn_PER_memb_regionId_constr_155,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P51, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_154,
		&asn_PER_memb_regExtValue_constr_156,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P51_tags_154[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P51_tag2el_154[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P51_specs_154 = {
	sizeof(struct RegionalExtension_92P51),
	offsetof(struct RegionalExtension_92P51, _asn_ctx),
	asn_MAP_RegionalExtension_92P51_tag2el_154,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P51 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P51_tags_154,
	sizeof(asn_DEF_RegionalExtension_92P51_tags_154)
		/sizeof(asn_DEF_RegionalExtension_92P51_tags_154[0]), /* 1 */
	asn_DEF_RegionalExtension_92P51_tags_154,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P51_tags_154)
		/sizeof(asn_DEF_RegionalExtension_92P51_tags_154[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P51_154,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P51_specs_154	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P52_157[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P52, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_157,
		&asn_PER_memb_regionId_constr_158,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P52, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_157,
		&asn_PER_memb_regExtValue_constr_159,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P52_tags_157[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P52_tag2el_157[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P52_specs_157 = {
	sizeof(struct RegionalExtension_92P52),
	offsetof(struct RegionalExtension_92P52, _asn_ctx),
	asn_MAP_RegionalExtension_92P52_tag2el_157,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P52 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P52_tags_157,
	sizeof(asn_DEF_RegionalExtension_92P52_tags_157)
		/sizeof(asn_DEF_RegionalExtension_92P52_tags_157[0]), /* 1 */
	asn_DEF_RegionalExtension_92P52_tags_157,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P52_tags_157)
		/sizeof(asn_DEF_RegionalExtension_92P52_tags_157[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P52_157,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P52_specs_157	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P53_160[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P53, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_160,
		&asn_PER_memb_regionId_constr_161,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P53, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_160,
		&asn_PER_memb_regExtValue_constr_162,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P53_tags_160[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P53_tag2el_160[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P53_specs_160 = {
	sizeof(struct RegionalExtension_92P53),
	offsetof(struct RegionalExtension_92P53, _asn_ctx),
	asn_MAP_RegionalExtension_92P53_tag2el_160,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P53 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P53_tags_160,
	sizeof(asn_DEF_RegionalExtension_92P53_tags_160)
		/sizeof(asn_DEF_RegionalExtension_92P53_tags_160[0]), /* 1 */
	asn_DEF_RegionalExtension_92P53_tags_160,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P53_tags_160)
		/sizeof(asn_DEF_RegionalExtension_92P53_tags_160[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P53_160,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P53_specs_160	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P54_163[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P54, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_163,
		&asn_PER_memb_regionId_constr_164,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P54, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_163,
		&asn_PER_memb_regExtValue_constr_165,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P54_tags_163[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P54_tag2el_163[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P54_specs_163 = {
	sizeof(struct RegionalExtension_92P54),
	offsetof(struct RegionalExtension_92P54, _asn_ctx),
	asn_MAP_RegionalExtension_92P54_tag2el_163,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P54 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P54_tags_163,
	sizeof(asn_DEF_RegionalExtension_92P54_tags_163)
		/sizeof(asn_DEF_RegionalExtension_92P54_tags_163[0]), /* 1 */
	asn_DEF_RegionalExtension_92P54_tags_163,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P54_tags_163)
		/sizeof(asn_DEF_RegionalExtension_92P54_tags_163[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P54_163,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P54_specs_163	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P55_166[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P55, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_166,
		&asn_PER_memb_regionId_constr_167,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P55, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_166,
		&asn_PER_memb_regExtValue_constr_168,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P55_tags_166[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P55_tag2el_166[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P55_specs_166 = {
	sizeof(struct RegionalExtension_92P55),
	offsetof(struct RegionalExtension_92P55, _asn_ctx),
	asn_MAP_RegionalExtension_92P55_tag2el_166,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P55 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P55_tags_166,
	sizeof(asn_DEF_RegionalExtension_92P55_tags_166)
		/sizeof(asn_DEF_RegionalExtension_92P55_tags_166[0]), /* 1 */
	asn_DEF_RegionalExtension_92P55_tags_166,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P55_tags_166)
		/sizeof(asn_DEF_RegionalExtension_92P55_tags_166[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P55_166,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P55_specs_166	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P56_169[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P56, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_169,
		&asn_PER_memb_regionId_constr_170,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P56, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_169,
		&asn_PER_memb_regExtValue_constr_171,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P56_tags_169[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P56_tag2el_169[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P56_specs_169 = {
	sizeof(struct RegionalExtension_92P56),
	offsetof(struct RegionalExtension_92P56, _asn_ctx),
	asn_MAP_RegionalExtension_92P56_tag2el_169,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P56 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P56_tags_169,
	sizeof(asn_DEF_RegionalExtension_92P56_tags_169)
		/sizeof(asn_DEF_RegionalExtension_92P56_tags_169[0]), /* 1 */
	asn_DEF_RegionalExtension_92P56_tags_169,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P56_tags_169)
		/sizeof(asn_DEF_RegionalExtension_92P56_tags_169[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P56_169,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P56_specs_169	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P57_172[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P57, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_172,
		&asn_PER_memb_regionId_constr_173,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P57, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_172,
		&asn_PER_memb_regExtValue_constr_174,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P57_tags_172[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P57_tag2el_172[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P57_specs_172 = {
	sizeof(struct RegionalExtension_92P57),
	offsetof(struct RegionalExtension_92P57, _asn_ctx),
	asn_MAP_RegionalExtension_92P57_tag2el_172,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P57 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P57_tags_172,
	sizeof(asn_DEF_RegionalExtension_92P57_tags_172)
		/sizeof(asn_DEF_RegionalExtension_92P57_tags_172[0]), /* 1 */
	asn_DEF_RegionalExtension_92P57_tags_172,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P57_tags_172)
		/sizeof(asn_DEF_RegionalExtension_92P57_tags_172[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P57_172,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P57_specs_172	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P58_175[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P58, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_175,
		&asn_PER_memb_regionId_constr_176,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P58, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_175,
		&asn_PER_memb_regExtValue_constr_177,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P58_tags_175[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P58_tag2el_175[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P58_specs_175 = {
	sizeof(struct RegionalExtension_92P58),
	offsetof(struct RegionalExtension_92P58, _asn_ctx),
	asn_MAP_RegionalExtension_92P58_tag2el_175,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P58 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P58_tags_175,
	sizeof(asn_DEF_RegionalExtension_92P58_tags_175)
		/sizeof(asn_DEF_RegionalExtension_92P58_tags_175[0]), /* 1 */
	asn_DEF_RegionalExtension_92P58_tags_175,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P58_tags_175)
		/sizeof(asn_DEF_RegionalExtension_92P58_tags_175[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P58_175,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P58_specs_175	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P59_178[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P59, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_178,
		&asn_PER_memb_regionId_constr_179,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P59, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_178,
		&asn_PER_memb_regExtValue_constr_180,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P59_tags_178[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P59_tag2el_178[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P59_specs_178 = {
	sizeof(struct RegionalExtension_92P59),
	offsetof(struct RegionalExtension_92P59, _asn_ctx),
	asn_MAP_RegionalExtension_92P59_tag2el_178,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P59 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P59_tags_178,
	sizeof(asn_DEF_RegionalExtension_92P59_tags_178)
		/sizeof(asn_DEF_RegionalExtension_92P59_tags_178[0]), /* 1 */
	asn_DEF_RegionalExtension_92P59_tags_178,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P59_tags_178)
		/sizeof(asn_DEF_RegionalExtension_92P59_tags_178[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P59_178,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P59_specs_178	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_RegionalExtension_92P60_181[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P60, regionId),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_RegionId,
		memb_regionId_constraint_181,
		&asn_PER_memb_regionId_constr_182,
		0,
		"regionId"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RegionalExtension_92P60, regExtValue),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_ANY,
		memb_regExtValue_constraint_181,
		&asn_PER_memb_regExtValue_constr_183,
		0,
		"regExtValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RegionalExtension_92P60_tags_181[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RegionalExtension_92P60_tag2el_181[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* regionId */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* regExtValue */
};
static asn_SEQUENCE_specifics_t asn_SPC_RegionalExtension_92P60_specs_181 = {
	sizeof(struct RegionalExtension_92P60),
	offsetof(struct RegionalExtension_92P60, _asn_ctx),
	asn_MAP_RegionalExtension_92P60_tag2el_181,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_RegionalExtension_92P60 = {
	"RegionalExtension",
	"RegionalExtension",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	SEQUENCE_decode_aper,
	SEQUENCE_encode_aper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_RegionalExtension_92P60_tags_181,
	sizeof(asn_DEF_RegionalExtension_92P60_tags_181)
		/sizeof(asn_DEF_RegionalExtension_92P60_tags_181[0]), /* 1 */
	asn_DEF_RegionalExtension_92P60_tags_181,	/* Same as above */
	sizeof(asn_DEF_RegionalExtension_92P60_tags_181)
		/sizeof(asn_DEF_RegionalExtension_92P60_tags_181[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_RegionalExtension_92P60_181,
	2,	/* Elements count */
	&asn_SPC_RegionalExtension_92P60_specs_181	/* Additional specs */
};

